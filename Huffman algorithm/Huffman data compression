class Node:
    def __init__(self, weight, value=None, left=None, right=None):
        self.weight = weight
        self.value = value
        self.left = left
        self.right = right

    def is_leaf(self):
        return self.value is not None
    
def build_huffman_tree(freq):
    nodes = []

    for byte, count in freq.items():
        nodes.append(Node(weight=count, value=byte))

    while len(nodes) > 1:
        nodes.sort(key=lambda n: n.weight)

        left_child = nodes.pop(0)
        right_child = nodes.pop(0)

        parent = Node(
            weight=left_child.weight + right_child.weight,
            left=left_child,
            right=right_child
        )

        nodes.append(parent)

    return nodes[0]
    
def generate_codes(node, prefix="", codebook=None):
    if codebook is None:
        codebook = {}

    if node.is_leaf():
        codebook[node.value] = prefix
        return codebook

    generate_codes(node.left, prefix + "0", codebook)
    generate_codes(node.right, prefix + "1", codebook)

    return codebook

def compress_data(data, codes):
    bit_buffer = ""
    compressed = bytearray()

    for b in data:
        bit_buffer += codes[b]

        while len(bit_buffer) >= 8:
            byte = bit_buffer[:8]
            bit_buffer = bit_buffer[8:]
            compressed.append(int(byte[::-1], 2)) 


    if bit_buffer:
        bit_buffer = bit_buffer[::-1]
        bit_buffer = bit_buffer.ljust(8, "0")
        compressed.append(int(bit_buffer, 2))

    return compressed


def huff():
    with open(r"C:\Users\dmmol\OneDrive\Documents\GitHub\Binary-data-encoding-algorithms\Huffman algorithm\Exe files\whois64.exe", "rb") as f:
        data = f.read()
        freq = {}

        for b in data:
            if b in freq:
                freq[b] += 1
            else:
                freq[b] = 1

        freq = dict(sorted(freq.items()))
        
        root = build_huffman_tree(freq)
        codes = generate_codes(root)
            
        for k in list(codes):
            print(f"byte {k} -> code {codes[k]}")

        data_comp = compress_data(data, codes)

        
    with open(r"C:\Users\dmmol\OneDrive\Documents\GitHub\Binary-data-encoding-algorithms\Huffman algorithm\compressed.txt", "wb") as ff:
        for byte in range(256):
            count = freq.get(byte)
            ff.write(count.to_bytes(4, byteorder="little", signed=False))
        ff.write(data_comp)
        
    

if __name__ == "__main__":
    huff()