class Node:
    def __init__(self, weight, value=None, left=None, right=None):
        self.weight = weight
        self.value = value
        self.left = left
        self.right = right

    def is_leaf(self):
        return self.value is not None
    
def build_huffman_tree(freq):
    nodes = []

    for byte, count in freq.items():
        nodes.append(Node(weight=count, value=byte))

    while len(nodes) > 1:
        nodes.sort(key=lambda n: n.weight)

        left_child = nodes.pop(0)
        right_child = nodes.pop(0)

        parent = Node(
            weight=left_child.weight + right_child.weight,
            left=left_child,
            right=right_child
        )

        nodes.append(parent)

    return nodes[0]
    
def generate_codes(node, prefix="", codebook=None):
    if codebook is None:
        codebook = {}

    if node.is_leaf():
        codebook[node.value] = prefix
        return codebook

    generate_codes(node.left, prefix + "0", codebook)
    generate_codes(node.right, prefix + "1", codebook)

    return codebook


def huff():
    with open(r"C:\Users\dmmol\OneDrive\Documents\GitHub\Binary-data-encoding-algorithms\Huffman algorithm\np.exe", "rb") as f:
        data = f.read()
        freq = {}

        for b in data:
            if b in freq:
                freq[b] += 1
            else:
                freq[b] = 1

        freq = dict(sorted(freq.items()))
        print(freq)
        
        root = build_huffman_tree(freq)
        codes = generate_codes(root)
        
        for k in list(codes):
            print(f"byte {k} -> code {codes[k]}")

        data_comp = ""

        #creating a tree
        
    

if __name__ == "__main__":
    huff()